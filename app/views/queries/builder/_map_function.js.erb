<%
  # This partial defines the map function of MapReduce jobs. It handles the logic of blank UI zones, generates functions that match the passed in query_structure,
  # and emits requested information.
  #
  # Locals
  # query_structure - The JSON that represents the query for which we're writing the map function.
%>

function extractPatient(patient) {
  <% 
   groups = [] 
   query_structure['extract']['groups'].each do |group| 
     args = (group['title'] == 'age') ? 'new Date()' : ''
     groups << "{title: '#{group['title']}',  value: patient.#{group['callstack']}(#{args}) }"
   end 

   values = []
   query_structure['extract']['selections'].each do |select| 
     args = (select['title'] == 'age') ? 'new Date()' : ''
     values << "{title: '#{select['title']}',  value: patient.#{select['callstack']}(#{args}) }"
   end

   final_values = '{values: [{value:1}] }';
   if (values.length > 0)
     final_values =  "[#{values.join(',')}]"
   end
   final_group = '[{title: null,  value: null}]'
   if (groups.length > 0)
     final_groups =  "[#{groups.join(',')}]"
   end
  %>  
  emit({type: 'group', value: <%= final_groups %> }, {values: <%= final_values %>});
}

function find(patient) {
  var root = new queryStructure.Or(null, [
  <% query_structure['find']['and'].each do |subelement|
    if subelement != query_structure['find']['and'].last
      comma_if_last = ','
    end %>
    <%= render :partial => '/queries/builder/build_where', :locals => { :element => subelement, :comma_if_last => comma_if_last } %>
  <% end %>
  ]);
  return root.test(patient);
}

function filter(patient) {
  var root = new queryStructure.Or(null, [
  <% query_structure['filter']['and'].each do |subelement|
    if subelement != query_structure['filter']['and'].last
      comma_if_last = ','
    end %>
    <%= render :partial => '/queries/builder/build_where', :locals => { :element => subelement, :comma_if_last => comma_if_last } %>
  <% end %>
  ]);
  return root.test(patient);
}

function map(patient) {  
  if (find(patient)) {
    if (filter(patient)) {
      emit({type: 'magic', value: 'target_pop' }, {values: [{value:1}] });
      extractPatient(patient);
    } else {
      emit({type: 'magic', value: 'filtered_pop' }, {values: [{value:1}] });
    }
  }
  else {
    emit({type: 'magic', value: 'unfound_pop' }, {values: [{value:1}] });
  }
  emit({type: 'magic', value: 'total_pop' }, {values: [{value:1}] });
}